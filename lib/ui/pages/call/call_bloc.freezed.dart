// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'call_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$CallEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() endCall,
    required TResult Function() toggleMic,
    required TResult Function() toggleSpeaker,
    required TResult Function() toggleVideo,
    required TResult Function() toggleView,
    required TResult Function() switchCamera,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? endCall,
    TResult? Function()? toggleMic,
    TResult? Function()? toggleSpeaker,
    TResult? Function()? toggleVideo,
    TResult? Function()? toggleView,
    TResult? Function()? switchCamera,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? endCall,
    TResult Function()? toggleMic,
    TResult Function()? toggleSpeaker,
    TResult Function()? toggleVideo,
    TResult Function()? toggleView,
    TResult Function()? switchCamera,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndCall value) endCall,
    required TResult Function(ToggleMic value) toggleMic,
    required TResult Function(ToggleSpeaker value) toggleSpeaker,
    required TResult Function(ToggleVideo value) toggleVideo,
    required TResult Function(ToggleView value) toggleView,
    required TResult Function(SwitchCamera value) switchCamera,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndCall value)? endCall,
    TResult? Function(ToggleMic value)? toggleMic,
    TResult? Function(ToggleSpeaker value)? toggleSpeaker,
    TResult? Function(ToggleVideo value)? toggleVideo,
    TResult? Function(ToggleView value)? toggleView,
    TResult? Function(SwitchCamera value)? switchCamera,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndCall value)? endCall,
    TResult Function(ToggleMic value)? toggleMic,
    TResult Function(ToggleSpeaker value)? toggleSpeaker,
    TResult Function(ToggleVideo value)? toggleVideo,
    TResult Function(ToggleView value)? toggleView,
    TResult Function(SwitchCamera value)? switchCamera,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CallEventCopyWith<$Res> {
  factory $CallEventCopyWith(CallEvent value, $Res Function(CallEvent) then) =
      _$CallEventCopyWithImpl<$Res, CallEvent>;
}

/// @nodoc
class _$CallEventCopyWithImpl<$Res, $Val extends CallEvent>
    implements $CallEventCopyWith<$Res> {
  _$CallEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EndCallCopyWith<$Res> {
  factory _$$EndCallCopyWith(_$EndCall value, $Res Function(_$EndCall) then) =
      __$$EndCallCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EndCallCopyWithImpl<$Res>
    extends _$CallEventCopyWithImpl<$Res, _$EndCall>
    implements _$$EndCallCopyWith<$Res> {
  __$$EndCallCopyWithImpl(_$EndCall _value, $Res Function(_$EndCall) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EndCall implements EndCall {
  const _$EndCall();

  @override
  String toString() {
    return 'CallEvent.endCall()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EndCall);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() endCall,
    required TResult Function() toggleMic,
    required TResult Function() toggleSpeaker,
    required TResult Function() toggleVideo,
    required TResult Function() toggleView,
    required TResult Function() switchCamera,
  }) {
    return endCall();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? endCall,
    TResult? Function()? toggleMic,
    TResult? Function()? toggleSpeaker,
    TResult? Function()? toggleVideo,
    TResult? Function()? toggleView,
    TResult? Function()? switchCamera,
  }) {
    return endCall?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? endCall,
    TResult Function()? toggleMic,
    TResult Function()? toggleSpeaker,
    TResult Function()? toggleVideo,
    TResult Function()? toggleView,
    TResult Function()? switchCamera,
    required TResult orElse(),
  }) {
    if (endCall != null) {
      return endCall();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndCall value) endCall,
    required TResult Function(ToggleMic value) toggleMic,
    required TResult Function(ToggleSpeaker value) toggleSpeaker,
    required TResult Function(ToggleVideo value) toggleVideo,
    required TResult Function(ToggleView value) toggleView,
    required TResult Function(SwitchCamera value) switchCamera,
  }) {
    return endCall(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndCall value)? endCall,
    TResult? Function(ToggleMic value)? toggleMic,
    TResult? Function(ToggleSpeaker value)? toggleSpeaker,
    TResult? Function(ToggleVideo value)? toggleVideo,
    TResult? Function(ToggleView value)? toggleView,
    TResult? Function(SwitchCamera value)? switchCamera,
  }) {
    return endCall?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndCall value)? endCall,
    TResult Function(ToggleMic value)? toggleMic,
    TResult Function(ToggleSpeaker value)? toggleSpeaker,
    TResult Function(ToggleVideo value)? toggleVideo,
    TResult Function(ToggleView value)? toggleView,
    TResult Function(SwitchCamera value)? switchCamera,
    required TResult orElse(),
  }) {
    if (endCall != null) {
      return endCall(this);
    }
    return orElse();
  }
}

abstract class EndCall implements CallEvent {
  const factory EndCall() = _$EndCall;
}

/// @nodoc
abstract class _$$ToggleMicCopyWith<$Res> {
  factory _$$ToggleMicCopyWith(
          _$ToggleMic value, $Res Function(_$ToggleMic) then) =
      __$$ToggleMicCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ToggleMicCopyWithImpl<$Res>
    extends _$CallEventCopyWithImpl<$Res, _$ToggleMic>
    implements _$$ToggleMicCopyWith<$Res> {
  __$$ToggleMicCopyWithImpl(
      _$ToggleMic _value, $Res Function(_$ToggleMic) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ToggleMic implements ToggleMic {
  const _$ToggleMic();

  @override
  String toString() {
    return 'CallEvent.toggleMic()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ToggleMic);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() endCall,
    required TResult Function() toggleMic,
    required TResult Function() toggleSpeaker,
    required TResult Function() toggleVideo,
    required TResult Function() toggleView,
    required TResult Function() switchCamera,
  }) {
    return toggleMic();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? endCall,
    TResult? Function()? toggleMic,
    TResult? Function()? toggleSpeaker,
    TResult? Function()? toggleVideo,
    TResult? Function()? toggleView,
    TResult? Function()? switchCamera,
  }) {
    return toggleMic?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? endCall,
    TResult Function()? toggleMic,
    TResult Function()? toggleSpeaker,
    TResult Function()? toggleVideo,
    TResult Function()? toggleView,
    TResult Function()? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleMic != null) {
      return toggleMic();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndCall value) endCall,
    required TResult Function(ToggleMic value) toggleMic,
    required TResult Function(ToggleSpeaker value) toggleSpeaker,
    required TResult Function(ToggleVideo value) toggleVideo,
    required TResult Function(ToggleView value) toggleView,
    required TResult Function(SwitchCamera value) switchCamera,
  }) {
    return toggleMic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndCall value)? endCall,
    TResult? Function(ToggleMic value)? toggleMic,
    TResult? Function(ToggleSpeaker value)? toggleSpeaker,
    TResult? Function(ToggleVideo value)? toggleVideo,
    TResult? Function(ToggleView value)? toggleView,
    TResult? Function(SwitchCamera value)? switchCamera,
  }) {
    return toggleMic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndCall value)? endCall,
    TResult Function(ToggleMic value)? toggleMic,
    TResult Function(ToggleSpeaker value)? toggleSpeaker,
    TResult Function(ToggleVideo value)? toggleVideo,
    TResult Function(ToggleView value)? toggleView,
    TResult Function(SwitchCamera value)? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleMic != null) {
      return toggleMic(this);
    }
    return orElse();
  }
}

abstract class ToggleMic implements CallEvent {
  const factory ToggleMic() = _$ToggleMic;
}

/// @nodoc
abstract class _$$ToggleSpeakerCopyWith<$Res> {
  factory _$$ToggleSpeakerCopyWith(
          _$ToggleSpeaker value, $Res Function(_$ToggleSpeaker) then) =
      __$$ToggleSpeakerCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ToggleSpeakerCopyWithImpl<$Res>
    extends _$CallEventCopyWithImpl<$Res, _$ToggleSpeaker>
    implements _$$ToggleSpeakerCopyWith<$Res> {
  __$$ToggleSpeakerCopyWithImpl(
      _$ToggleSpeaker _value, $Res Function(_$ToggleSpeaker) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ToggleSpeaker implements ToggleSpeaker {
  const _$ToggleSpeaker();

  @override
  String toString() {
    return 'CallEvent.toggleSpeaker()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ToggleSpeaker);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() endCall,
    required TResult Function() toggleMic,
    required TResult Function() toggleSpeaker,
    required TResult Function() toggleVideo,
    required TResult Function() toggleView,
    required TResult Function() switchCamera,
  }) {
    return toggleSpeaker();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? endCall,
    TResult? Function()? toggleMic,
    TResult? Function()? toggleSpeaker,
    TResult? Function()? toggleVideo,
    TResult? Function()? toggleView,
    TResult? Function()? switchCamera,
  }) {
    return toggleSpeaker?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? endCall,
    TResult Function()? toggleMic,
    TResult Function()? toggleSpeaker,
    TResult Function()? toggleVideo,
    TResult Function()? toggleView,
    TResult Function()? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleSpeaker != null) {
      return toggleSpeaker();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndCall value) endCall,
    required TResult Function(ToggleMic value) toggleMic,
    required TResult Function(ToggleSpeaker value) toggleSpeaker,
    required TResult Function(ToggleVideo value) toggleVideo,
    required TResult Function(ToggleView value) toggleView,
    required TResult Function(SwitchCamera value) switchCamera,
  }) {
    return toggleSpeaker(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndCall value)? endCall,
    TResult? Function(ToggleMic value)? toggleMic,
    TResult? Function(ToggleSpeaker value)? toggleSpeaker,
    TResult? Function(ToggleVideo value)? toggleVideo,
    TResult? Function(ToggleView value)? toggleView,
    TResult? Function(SwitchCamera value)? switchCamera,
  }) {
    return toggleSpeaker?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndCall value)? endCall,
    TResult Function(ToggleMic value)? toggleMic,
    TResult Function(ToggleSpeaker value)? toggleSpeaker,
    TResult Function(ToggleVideo value)? toggleVideo,
    TResult Function(ToggleView value)? toggleView,
    TResult Function(SwitchCamera value)? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleSpeaker != null) {
      return toggleSpeaker(this);
    }
    return orElse();
  }
}

abstract class ToggleSpeaker implements CallEvent {
  const factory ToggleSpeaker() = _$ToggleSpeaker;
}

/// @nodoc
abstract class _$$ToggleVideoCopyWith<$Res> {
  factory _$$ToggleVideoCopyWith(
          _$ToggleVideo value, $Res Function(_$ToggleVideo) then) =
      __$$ToggleVideoCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ToggleVideoCopyWithImpl<$Res>
    extends _$CallEventCopyWithImpl<$Res, _$ToggleVideo>
    implements _$$ToggleVideoCopyWith<$Res> {
  __$$ToggleVideoCopyWithImpl(
      _$ToggleVideo _value, $Res Function(_$ToggleVideo) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ToggleVideo implements ToggleVideo {
  const _$ToggleVideo();

  @override
  String toString() {
    return 'CallEvent.toggleVideo()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ToggleVideo);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() endCall,
    required TResult Function() toggleMic,
    required TResult Function() toggleSpeaker,
    required TResult Function() toggleVideo,
    required TResult Function() toggleView,
    required TResult Function() switchCamera,
  }) {
    return toggleVideo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? endCall,
    TResult? Function()? toggleMic,
    TResult? Function()? toggleSpeaker,
    TResult? Function()? toggleVideo,
    TResult? Function()? toggleView,
    TResult? Function()? switchCamera,
  }) {
    return toggleVideo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? endCall,
    TResult Function()? toggleMic,
    TResult Function()? toggleSpeaker,
    TResult Function()? toggleVideo,
    TResult Function()? toggleView,
    TResult Function()? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleVideo != null) {
      return toggleVideo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndCall value) endCall,
    required TResult Function(ToggleMic value) toggleMic,
    required TResult Function(ToggleSpeaker value) toggleSpeaker,
    required TResult Function(ToggleVideo value) toggleVideo,
    required TResult Function(ToggleView value) toggleView,
    required TResult Function(SwitchCamera value) switchCamera,
  }) {
    return toggleVideo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndCall value)? endCall,
    TResult? Function(ToggleMic value)? toggleMic,
    TResult? Function(ToggleSpeaker value)? toggleSpeaker,
    TResult? Function(ToggleVideo value)? toggleVideo,
    TResult? Function(ToggleView value)? toggleView,
    TResult? Function(SwitchCamera value)? switchCamera,
  }) {
    return toggleVideo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndCall value)? endCall,
    TResult Function(ToggleMic value)? toggleMic,
    TResult Function(ToggleSpeaker value)? toggleSpeaker,
    TResult Function(ToggleVideo value)? toggleVideo,
    TResult Function(ToggleView value)? toggleView,
    TResult Function(SwitchCamera value)? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleVideo != null) {
      return toggleVideo(this);
    }
    return orElse();
  }
}

abstract class ToggleVideo implements CallEvent {
  const factory ToggleVideo() = _$ToggleVideo;
}

/// @nodoc
abstract class _$$ToggleViewCopyWith<$Res> {
  factory _$$ToggleViewCopyWith(
          _$ToggleView value, $Res Function(_$ToggleView) then) =
      __$$ToggleViewCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ToggleViewCopyWithImpl<$Res>
    extends _$CallEventCopyWithImpl<$Res, _$ToggleView>
    implements _$$ToggleViewCopyWith<$Res> {
  __$$ToggleViewCopyWithImpl(
      _$ToggleView _value, $Res Function(_$ToggleView) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ToggleView implements ToggleView {
  const _$ToggleView();

  @override
  String toString() {
    return 'CallEvent.toggleView()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ToggleView);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() endCall,
    required TResult Function() toggleMic,
    required TResult Function() toggleSpeaker,
    required TResult Function() toggleVideo,
    required TResult Function() toggleView,
    required TResult Function() switchCamera,
  }) {
    return toggleView();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? endCall,
    TResult? Function()? toggleMic,
    TResult? Function()? toggleSpeaker,
    TResult? Function()? toggleVideo,
    TResult? Function()? toggleView,
    TResult? Function()? switchCamera,
  }) {
    return toggleView?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? endCall,
    TResult Function()? toggleMic,
    TResult Function()? toggleSpeaker,
    TResult Function()? toggleVideo,
    TResult Function()? toggleView,
    TResult Function()? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleView != null) {
      return toggleView();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndCall value) endCall,
    required TResult Function(ToggleMic value) toggleMic,
    required TResult Function(ToggleSpeaker value) toggleSpeaker,
    required TResult Function(ToggleVideo value) toggleVideo,
    required TResult Function(ToggleView value) toggleView,
    required TResult Function(SwitchCamera value) switchCamera,
  }) {
    return toggleView(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndCall value)? endCall,
    TResult? Function(ToggleMic value)? toggleMic,
    TResult? Function(ToggleSpeaker value)? toggleSpeaker,
    TResult? Function(ToggleVideo value)? toggleVideo,
    TResult? Function(ToggleView value)? toggleView,
    TResult? Function(SwitchCamera value)? switchCamera,
  }) {
    return toggleView?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndCall value)? endCall,
    TResult Function(ToggleMic value)? toggleMic,
    TResult Function(ToggleSpeaker value)? toggleSpeaker,
    TResult Function(ToggleVideo value)? toggleVideo,
    TResult Function(ToggleView value)? toggleView,
    TResult Function(SwitchCamera value)? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleView != null) {
      return toggleView(this);
    }
    return orElse();
  }
}

abstract class ToggleView implements CallEvent {
  const factory ToggleView() = _$ToggleView;
}

/// @nodoc
abstract class _$$SwitchCameraCopyWith<$Res> {
  factory _$$SwitchCameraCopyWith(
          _$SwitchCamera value, $Res Function(_$SwitchCamera) then) =
      __$$SwitchCameraCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwitchCameraCopyWithImpl<$Res>
    extends _$CallEventCopyWithImpl<$Res, _$SwitchCamera>
    implements _$$SwitchCameraCopyWith<$Res> {
  __$$SwitchCameraCopyWithImpl(
      _$SwitchCamera _value, $Res Function(_$SwitchCamera) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SwitchCamera implements SwitchCamera {
  const _$SwitchCamera();

  @override
  String toString() {
    return 'CallEvent.switchCamera()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SwitchCamera);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() endCall,
    required TResult Function() toggleMic,
    required TResult Function() toggleSpeaker,
    required TResult Function() toggleVideo,
    required TResult Function() toggleView,
    required TResult Function() switchCamera,
  }) {
    return switchCamera();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? endCall,
    TResult? Function()? toggleMic,
    TResult? Function()? toggleSpeaker,
    TResult? Function()? toggleVideo,
    TResult? Function()? toggleView,
    TResult? Function()? switchCamera,
  }) {
    return switchCamera?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? endCall,
    TResult Function()? toggleMic,
    TResult Function()? toggleSpeaker,
    TResult Function()? toggleVideo,
    TResult Function()? toggleView,
    TResult Function()? switchCamera,
    required TResult orElse(),
  }) {
    if (switchCamera != null) {
      return switchCamera();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndCall value) endCall,
    required TResult Function(ToggleMic value) toggleMic,
    required TResult Function(ToggleSpeaker value) toggleSpeaker,
    required TResult Function(ToggleVideo value) toggleVideo,
    required TResult Function(ToggleView value) toggleView,
    required TResult Function(SwitchCamera value) switchCamera,
  }) {
    return switchCamera(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndCall value)? endCall,
    TResult? Function(ToggleMic value)? toggleMic,
    TResult? Function(ToggleSpeaker value)? toggleSpeaker,
    TResult? Function(ToggleVideo value)? toggleVideo,
    TResult? Function(ToggleView value)? toggleView,
    TResult? Function(SwitchCamera value)? switchCamera,
  }) {
    return switchCamera?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndCall value)? endCall,
    TResult Function(ToggleMic value)? toggleMic,
    TResult Function(ToggleSpeaker value)? toggleSpeaker,
    TResult Function(ToggleVideo value)? toggleVideo,
    TResult Function(ToggleView value)? toggleView,
    TResult Function(SwitchCamera value)? switchCamera,
    required TResult orElse(),
  }) {
    if (switchCamera != null) {
      return switchCamera(this);
    }
    return orElse();
  }
}

abstract class SwitchCamera implements CallEvent {
  const factory SwitchCamera() = _$SwitchCamera;
}

/// @nodoc
mixin _$CallState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() reconnecting,
    required TResult Function() failed,
    required TResult Function() connected,
    required TResult Function(bool value, CallEvent event) changed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? reconnecting,
    TResult? Function()? failed,
    TResult? Function()? connected,
    TResult? Function(bool value, CallEvent event)? changed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? reconnecting,
    TResult Function()? failed,
    TResult Function()? connected,
    TResult Function(bool value, CallEvent event)? changed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Recconecting value) reconnecting,
    required TResult Function(Failed value) failed,
    required TResult Function(Connected value) connected,
    required TResult Function(Changed value) changed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Recconecting value)? reconnecting,
    TResult? Function(Failed value)? failed,
    TResult? Function(Connected value)? connected,
    TResult? Function(Changed value)? changed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Recconecting value)? reconnecting,
    TResult Function(Failed value)? failed,
    TResult Function(Connected value)? connected,
    TResult Function(Changed value)? changed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CallStateCopyWith<$Res> {
  factory $CallStateCopyWith(CallState value, $Res Function(CallState) then) =
      _$CallStateCopyWithImpl<$Res, CallState>;
}

/// @nodoc
class _$CallStateCopyWithImpl<$Res, $Val extends CallState>
    implements $CallStateCopyWith<$Res> {
  _$CallStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialCopyWith<$Res> {
  factory _$$InitialCopyWith(_$Initial value, $Res Function(_$Initial) then) =
      __$$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialCopyWithImpl<$Res>
    extends _$CallStateCopyWithImpl<$Res, _$Initial>
    implements _$$InitialCopyWith<$Res> {
  __$$InitialCopyWithImpl(_$Initial _value, $Res Function(_$Initial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Initial implements Initial {
  const _$Initial();

  @override
  String toString() {
    return 'CallState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() reconnecting,
    required TResult Function() failed,
    required TResult Function() connected,
    required TResult Function(bool value, CallEvent event) changed,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? reconnecting,
    TResult? Function()? failed,
    TResult? Function()? connected,
    TResult? Function(bool value, CallEvent event)? changed,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? reconnecting,
    TResult Function()? failed,
    TResult Function()? connected,
    TResult Function(bool value, CallEvent event)? changed,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Recconecting value) reconnecting,
    required TResult Function(Failed value) failed,
    required TResult Function(Connected value) connected,
    required TResult Function(Changed value) changed,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Recconecting value)? reconnecting,
    TResult? Function(Failed value)? failed,
    TResult? Function(Connected value)? connected,
    TResult? Function(Changed value)? changed,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Recconecting value)? reconnecting,
    TResult Function(Failed value)? failed,
    TResult Function(Connected value)? connected,
    TResult Function(Changed value)? changed,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class Initial implements CallState {
  const factory Initial() = _$Initial;
}

/// @nodoc
abstract class _$$RecconectingCopyWith<$Res> {
  factory _$$RecconectingCopyWith(
          _$Recconecting value, $Res Function(_$Recconecting) then) =
      __$$RecconectingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RecconectingCopyWithImpl<$Res>
    extends _$CallStateCopyWithImpl<$Res, _$Recconecting>
    implements _$$RecconectingCopyWith<$Res> {
  __$$RecconectingCopyWithImpl(
      _$Recconecting _value, $Res Function(_$Recconecting) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Recconecting implements Recconecting {
  const _$Recconecting();

  @override
  String toString() {
    return 'CallState.reconnecting()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Recconecting);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() reconnecting,
    required TResult Function() failed,
    required TResult Function() connected,
    required TResult Function(bool value, CallEvent event) changed,
  }) {
    return reconnecting();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? reconnecting,
    TResult? Function()? failed,
    TResult? Function()? connected,
    TResult? Function(bool value, CallEvent event)? changed,
  }) {
    return reconnecting?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? reconnecting,
    TResult Function()? failed,
    TResult Function()? connected,
    TResult Function(bool value, CallEvent event)? changed,
    required TResult orElse(),
  }) {
    if (reconnecting != null) {
      return reconnecting();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Recconecting value) reconnecting,
    required TResult Function(Failed value) failed,
    required TResult Function(Connected value) connected,
    required TResult Function(Changed value) changed,
  }) {
    return reconnecting(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Recconecting value)? reconnecting,
    TResult? Function(Failed value)? failed,
    TResult? Function(Connected value)? connected,
    TResult? Function(Changed value)? changed,
  }) {
    return reconnecting?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Recconecting value)? reconnecting,
    TResult Function(Failed value)? failed,
    TResult Function(Connected value)? connected,
    TResult Function(Changed value)? changed,
    required TResult orElse(),
  }) {
    if (reconnecting != null) {
      return reconnecting(this);
    }
    return orElse();
  }
}

abstract class Recconecting implements CallState {
  const factory Recconecting() = _$Recconecting;
}

/// @nodoc
abstract class _$$FailedCopyWith<$Res> {
  factory _$$FailedCopyWith(_$Failed value, $Res Function(_$Failed) then) =
      __$$FailedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FailedCopyWithImpl<$Res>
    extends _$CallStateCopyWithImpl<$Res, _$Failed>
    implements _$$FailedCopyWith<$Res> {
  __$$FailedCopyWithImpl(_$Failed _value, $Res Function(_$Failed) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Failed implements Failed {
  const _$Failed();

  @override
  String toString() {
    return 'CallState.failed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Failed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() reconnecting,
    required TResult Function() failed,
    required TResult Function() connected,
    required TResult Function(bool value, CallEvent event) changed,
  }) {
    return failed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? reconnecting,
    TResult? Function()? failed,
    TResult? Function()? connected,
    TResult? Function(bool value, CallEvent event)? changed,
  }) {
    return failed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? reconnecting,
    TResult Function()? failed,
    TResult Function()? connected,
    TResult Function(bool value, CallEvent event)? changed,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Recconecting value) reconnecting,
    required TResult Function(Failed value) failed,
    required TResult Function(Connected value) connected,
    required TResult Function(Changed value) changed,
  }) {
    return failed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Recconecting value)? reconnecting,
    TResult? Function(Failed value)? failed,
    TResult? Function(Connected value)? connected,
    TResult? Function(Changed value)? changed,
  }) {
    return failed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Recconecting value)? reconnecting,
    TResult Function(Failed value)? failed,
    TResult Function(Connected value)? connected,
    TResult Function(Changed value)? changed,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(this);
    }
    return orElse();
  }
}

abstract class Failed implements CallState {
  const factory Failed() = _$Failed;
}

/// @nodoc
abstract class _$$ConnectedCopyWith<$Res> {
  factory _$$ConnectedCopyWith(
          _$Connected value, $Res Function(_$Connected) then) =
      __$$ConnectedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConnectedCopyWithImpl<$Res>
    extends _$CallStateCopyWithImpl<$Res, _$Connected>
    implements _$$ConnectedCopyWith<$Res> {
  __$$ConnectedCopyWithImpl(
      _$Connected _value, $Res Function(_$Connected) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Connected implements Connected {
  const _$Connected();

  @override
  String toString() {
    return 'CallState.connected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Connected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() reconnecting,
    required TResult Function() failed,
    required TResult Function() connected,
    required TResult Function(bool value, CallEvent event) changed,
  }) {
    return connected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? reconnecting,
    TResult? Function()? failed,
    TResult? Function()? connected,
    TResult? Function(bool value, CallEvent event)? changed,
  }) {
    return connected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? reconnecting,
    TResult Function()? failed,
    TResult Function()? connected,
    TResult Function(bool value, CallEvent event)? changed,
    required TResult orElse(),
  }) {
    if (connected != null) {
      return connected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Recconecting value) reconnecting,
    required TResult Function(Failed value) failed,
    required TResult Function(Connected value) connected,
    required TResult Function(Changed value) changed,
  }) {
    return connected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Recconecting value)? reconnecting,
    TResult? Function(Failed value)? failed,
    TResult? Function(Connected value)? connected,
    TResult? Function(Changed value)? changed,
  }) {
    return connected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Recconecting value)? reconnecting,
    TResult Function(Failed value)? failed,
    TResult Function(Connected value)? connected,
    TResult Function(Changed value)? changed,
    required TResult orElse(),
  }) {
    if (connected != null) {
      return connected(this);
    }
    return orElse();
  }
}

abstract class Connected implements CallState {
  const factory Connected() = _$Connected;
}

/// @nodoc
abstract class _$$ChangedCopyWith<$Res> {
  factory _$$ChangedCopyWith(_$Changed value, $Res Function(_$Changed) then) =
      __$$ChangedCopyWithImpl<$Res>;
  @useResult
  $Res call({bool value, CallEvent event});

  $CallEventCopyWith<$Res> get event;
}

/// @nodoc
class __$$ChangedCopyWithImpl<$Res>
    extends _$CallStateCopyWithImpl<$Res, _$Changed>
    implements _$$ChangedCopyWith<$Res> {
  __$$ChangedCopyWithImpl(_$Changed _value, $Res Function(_$Changed) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
    Object? event = null,
  }) {
    return _then(_$Changed(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as bool,
      null == event
          ? _value.event
          : event // ignore: cast_nullable_to_non_nullable
              as CallEvent,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $CallEventCopyWith<$Res> get event {
    return $CallEventCopyWith<$Res>(_value.event, (value) {
      return _then(_value.copyWith(event: value));
    });
  }
}

/// @nodoc

class _$Changed implements Changed {
  const _$Changed(this.value, this.event);

  @override
  final bool value;
  @override
  final CallEvent event;

  @override
  String toString() {
    return 'CallState.changed(value: $value, event: $event)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Changed &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.event, event) || other.event == event));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value, event);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChangedCopyWith<_$Changed> get copyWith =>
      __$$ChangedCopyWithImpl<_$Changed>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() reconnecting,
    required TResult Function() failed,
    required TResult Function() connected,
    required TResult Function(bool value, CallEvent event) changed,
  }) {
    return changed(value, event);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? reconnecting,
    TResult? Function()? failed,
    TResult? Function()? connected,
    TResult? Function(bool value, CallEvent event)? changed,
  }) {
    return changed?.call(value, event);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? reconnecting,
    TResult Function()? failed,
    TResult Function()? connected,
    TResult Function(bool value, CallEvent event)? changed,
    required TResult orElse(),
  }) {
    if (changed != null) {
      return changed(value, event);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Recconecting value) reconnecting,
    required TResult Function(Failed value) failed,
    required TResult Function(Connected value) connected,
    required TResult Function(Changed value) changed,
  }) {
    return changed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Recconecting value)? reconnecting,
    TResult? Function(Failed value)? failed,
    TResult? Function(Connected value)? connected,
    TResult? Function(Changed value)? changed,
  }) {
    return changed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Recconecting value)? reconnecting,
    TResult Function(Failed value)? failed,
    TResult Function(Connected value)? connected,
    TResult Function(Changed value)? changed,
    required TResult orElse(),
  }) {
    if (changed != null) {
      return changed(this);
    }
    return orElse();
  }
}

abstract class Changed implements CallState {
  const factory Changed(final bool value, final CallEvent event) = _$Changed;

  bool get value;
  CallEvent get event;
  @JsonKey(ignore: true)
  _$$ChangedCopyWith<_$Changed> get copyWith =>
      throw _privateConstructorUsedError;
}
