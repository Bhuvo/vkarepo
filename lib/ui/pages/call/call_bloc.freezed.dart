// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'call_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$CallEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() endCall,
    required TResult Function() toggleMic,
    required TResult Function() toggleSpeaker,
    required TResult Function() toggleVideo,
    required TResult Function() toggleView,
    required TResult Function() switchCamera,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? endCall,
    TResult? Function()? toggleMic,
    TResult? Function()? toggleSpeaker,
    TResult? Function()? toggleVideo,
    TResult? Function()? toggleView,
    TResult? Function()? switchCamera,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? endCall,
    TResult Function()? toggleMic,
    TResult Function()? toggleSpeaker,
    TResult Function()? toggleVideo,
    TResult Function()? toggleView,
    TResult Function()? switchCamera,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndCall value) endCall,
    required TResult Function(ToggleMic value) toggleMic,
    required TResult Function(ToggleSpeaker value) toggleSpeaker,
    required TResult Function(ToggleVideo value) toggleVideo,
    required TResult Function(ToggleView value) toggleView,
    required TResult Function(SwitchCamera value) switchCamera,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndCall value)? endCall,
    TResult? Function(ToggleMic value)? toggleMic,
    TResult? Function(ToggleSpeaker value)? toggleSpeaker,
    TResult? Function(ToggleVideo value)? toggleVideo,
    TResult? Function(ToggleView value)? toggleView,
    TResult? Function(SwitchCamera value)? switchCamera,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndCall value)? endCall,
    TResult Function(ToggleMic value)? toggleMic,
    TResult Function(ToggleSpeaker value)? toggleSpeaker,
    TResult Function(ToggleVideo value)? toggleVideo,
    TResult Function(ToggleView value)? toggleView,
    TResult Function(SwitchCamera value)? switchCamera,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CallEventCopyWith<$Res> {
  factory $CallEventCopyWith(CallEvent value, $Res Function(CallEvent) then) =
      _$CallEventCopyWithImpl<$Res, CallEvent>;
}

/// @nodoc
class _$CallEventCopyWithImpl<$Res, $Val extends CallEvent>
    implements $CallEventCopyWith<$Res> {
  _$CallEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CallEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$EndCallImplCopyWith<$Res> {
  factory _$$EndCallImplCopyWith(
          _$EndCallImpl value, $Res Function(_$EndCallImpl) then) =
      __$$EndCallImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EndCallImplCopyWithImpl<$Res>
    extends _$CallEventCopyWithImpl<$Res, _$EndCallImpl>
    implements _$$EndCallImplCopyWith<$Res> {
  __$$EndCallImplCopyWithImpl(
      _$EndCallImpl _value, $Res Function(_$EndCallImpl) _then)
      : super(_value, _then);

  /// Create a copy of CallEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$EndCallImpl implements EndCall {
  const _$EndCallImpl();

  @override
  String toString() {
    return 'CallEvent.endCall()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EndCallImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() endCall,
    required TResult Function() toggleMic,
    required TResult Function() toggleSpeaker,
    required TResult Function() toggleVideo,
    required TResult Function() toggleView,
    required TResult Function() switchCamera,
  }) {
    return endCall();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? endCall,
    TResult? Function()? toggleMic,
    TResult? Function()? toggleSpeaker,
    TResult? Function()? toggleVideo,
    TResult? Function()? toggleView,
    TResult? Function()? switchCamera,
  }) {
    return endCall?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? endCall,
    TResult Function()? toggleMic,
    TResult Function()? toggleSpeaker,
    TResult Function()? toggleVideo,
    TResult Function()? toggleView,
    TResult Function()? switchCamera,
    required TResult orElse(),
  }) {
    if (endCall != null) {
      return endCall();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndCall value) endCall,
    required TResult Function(ToggleMic value) toggleMic,
    required TResult Function(ToggleSpeaker value) toggleSpeaker,
    required TResult Function(ToggleVideo value) toggleVideo,
    required TResult Function(ToggleView value) toggleView,
    required TResult Function(SwitchCamera value) switchCamera,
  }) {
    return endCall(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndCall value)? endCall,
    TResult? Function(ToggleMic value)? toggleMic,
    TResult? Function(ToggleSpeaker value)? toggleSpeaker,
    TResult? Function(ToggleVideo value)? toggleVideo,
    TResult? Function(ToggleView value)? toggleView,
    TResult? Function(SwitchCamera value)? switchCamera,
  }) {
    return endCall?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndCall value)? endCall,
    TResult Function(ToggleMic value)? toggleMic,
    TResult Function(ToggleSpeaker value)? toggleSpeaker,
    TResult Function(ToggleVideo value)? toggleVideo,
    TResult Function(ToggleView value)? toggleView,
    TResult Function(SwitchCamera value)? switchCamera,
    required TResult orElse(),
  }) {
    if (endCall != null) {
      return endCall(this);
    }
    return orElse();
  }
}

abstract class EndCall implements CallEvent {
  const factory EndCall() = _$EndCallImpl;
}

/// @nodoc
abstract class _$$ToggleMicImplCopyWith<$Res> {
  factory _$$ToggleMicImplCopyWith(
          _$ToggleMicImpl value, $Res Function(_$ToggleMicImpl) then) =
      __$$ToggleMicImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ToggleMicImplCopyWithImpl<$Res>
    extends _$CallEventCopyWithImpl<$Res, _$ToggleMicImpl>
    implements _$$ToggleMicImplCopyWith<$Res> {
  __$$ToggleMicImplCopyWithImpl(
      _$ToggleMicImpl _value, $Res Function(_$ToggleMicImpl) _then)
      : super(_value, _then);

  /// Create a copy of CallEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ToggleMicImpl implements ToggleMic {
  const _$ToggleMicImpl();

  @override
  String toString() {
    return 'CallEvent.toggleMic()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ToggleMicImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() endCall,
    required TResult Function() toggleMic,
    required TResult Function() toggleSpeaker,
    required TResult Function() toggleVideo,
    required TResult Function() toggleView,
    required TResult Function() switchCamera,
  }) {
    return toggleMic();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? endCall,
    TResult? Function()? toggleMic,
    TResult? Function()? toggleSpeaker,
    TResult? Function()? toggleVideo,
    TResult? Function()? toggleView,
    TResult? Function()? switchCamera,
  }) {
    return toggleMic?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? endCall,
    TResult Function()? toggleMic,
    TResult Function()? toggleSpeaker,
    TResult Function()? toggleVideo,
    TResult Function()? toggleView,
    TResult Function()? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleMic != null) {
      return toggleMic();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndCall value) endCall,
    required TResult Function(ToggleMic value) toggleMic,
    required TResult Function(ToggleSpeaker value) toggleSpeaker,
    required TResult Function(ToggleVideo value) toggleVideo,
    required TResult Function(ToggleView value) toggleView,
    required TResult Function(SwitchCamera value) switchCamera,
  }) {
    return toggleMic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndCall value)? endCall,
    TResult? Function(ToggleMic value)? toggleMic,
    TResult? Function(ToggleSpeaker value)? toggleSpeaker,
    TResult? Function(ToggleVideo value)? toggleVideo,
    TResult? Function(ToggleView value)? toggleView,
    TResult? Function(SwitchCamera value)? switchCamera,
  }) {
    return toggleMic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndCall value)? endCall,
    TResult Function(ToggleMic value)? toggleMic,
    TResult Function(ToggleSpeaker value)? toggleSpeaker,
    TResult Function(ToggleVideo value)? toggleVideo,
    TResult Function(ToggleView value)? toggleView,
    TResult Function(SwitchCamera value)? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleMic != null) {
      return toggleMic(this);
    }
    return orElse();
  }
}

abstract class ToggleMic implements CallEvent {
  const factory ToggleMic() = _$ToggleMicImpl;
}

/// @nodoc
abstract class _$$ToggleSpeakerImplCopyWith<$Res> {
  factory _$$ToggleSpeakerImplCopyWith(
          _$ToggleSpeakerImpl value, $Res Function(_$ToggleSpeakerImpl) then) =
      __$$ToggleSpeakerImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ToggleSpeakerImplCopyWithImpl<$Res>
    extends _$CallEventCopyWithImpl<$Res, _$ToggleSpeakerImpl>
    implements _$$ToggleSpeakerImplCopyWith<$Res> {
  __$$ToggleSpeakerImplCopyWithImpl(
      _$ToggleSpeakerImpl _value, $Res Function(_$ToggleSpeakerImpl) _then)
      : super(_value, _then);

  /// Create a copy of CallEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ToggleSpeakerImpl implements ToggleSpeaker {
  const _$ToggleSpeakerImpl();

  @override
  String toString() {
    return 'CallEvent.toggleSpeaker()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ToggleSpeakerImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() endCall,
    required TResult Function() toggleMic,
    required TResult Function() toggleSpeaker,
    required TResult Function() toggleVideo,
    required TResult Function() toggleView,
    required TResult Function() switchCamera,
  }) {
    return toggleSpeaker();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? endCall,
    TResult? Function()? toggleMic,
    TResult? Function()? toggleSpeaker,
    TResult? Function()? toggleVideo,
    TResult? Function()? toggleView,
    TResult? Function()? switchCamera,
  }) {
    return toggleSpeaker?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? endCall,
    TResult Function()? toggleMic,
    TResult Function()? toggleSpeaker,
    TResult Function()? toggleVideo,
    TResult Function()? toggleView,
    TResult Function()? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleSpeaker != null) {
      return toggleSpeaker();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndCall value) endCall,
    required TResult Function(ToggleMic value) toggleMic,
    required TResult Function(ToggleSpeaker value) toggleSpeaker,
    required TResult Function(ToggleVideo value) toggleVideo,
    required TResult Function(ToggleView value) toggleView,
    required TResult Function(SwitchCamera value) switchCamera,
  }) {
    return toggleSpeaker(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndCall value)? endCall,
    TResult? Function(ToggleMic value)? toggleMic,
    TResult? Function(ToggleSpeaker value)? toggleSpeaker,
    TResult? Function(ToggleVideo value)? toggleVideo,
    TResult? Function(ToggleView value)? toggleView,
    TResult? Function(SwitchCamera value)? switchCamera,
  }) {
    return toggleSpeaker?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndCall value)? endCall,
    TResult Function(ToggleMic value)? toggleMic,
    TResult Function(ToggleSpeaker value)? toggleSpeaker,
    TResult Function(ToggleVideo value)? toggleVideo,
    TResult Function(ToggleView value)? toggleView,
    TResult Function(SwitchCamera value)? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleSpeaker != null) {
      return toggleSpeaker(this);
    }
    return orElse();
  }
}

abstract class ToggleSpeaker implements CallEvent {
  const factory ToggleSpeaker() = _$ToggleSpeakerImpl;
}

/// @nodoc
abstract class _$$ToggleVideoImplCopyWith<$Res> {
  factory _$$ToggleVideoImplCopyWith(
          _$ToggleVideoImpl value, $Res Function(_$ToggleVideoImpl) then) =
      __$$ToggleVideoImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ToggleVideoImplCopyWithImpl<$Res>
    extends _$CallEventCopyWithImpl<$Res, _$ToggleVideoImpl>
    implements _$$ToggleVideoImplCopyWith<$Res> {
  __$$ToggleVideoImplCopyWithImpl(
      _$ToggleVideoImpl _value, $Res Function(_$ToggleVideoImpl) _then)
      : super(_value, _then);

  /// Create a copy of CallEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ToggleVideoImpl implements ToggleVideo {
  const _$ToggleVideoImpl();

  @override
  String toString() {
    return 'CallEvent.toggleVideo()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ToggleVideoImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() endCall,
    required TResult Function() toggleMic,
    required TResult Function() toggleSpeaker,
    required TResult Function() toggleVideo,
    required TResult Function() toggleView,
    required TResult Function() switchCamera,
  }) {
    return toggleVideo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? endCall,
    TResult? Function()? toggleMic,
    TResult? Function()? toggleSpeaker,
    TResult? Function()? toggleVideo,
    TResult? Function()? toggleView,
    TResult? Function()? switchCamera,
  }) {
    return toggleVideo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? endCall,
    TResult Function()? toggleMic,
    TResult Function()? toggleSpeaker,
    TResult Function()? toggleVideo,
    TResult Function()? toggleView,
    TResult Function()? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleVideo != null) {
      return toggleVideo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndCall value) endCall,
    required TResult Function(ToggleMic value) toggleMic,
    required TResult Function(ToggleSpeaker value) toggleSpeaker,
    required TResult Function(ToggleVideo value) toggleVideo,
    required TResult Function(ToggleView value) toggleView,
    required TResult Function(SwitchCamera value) switchCamera,
  }) {
    return toggleVideo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndCall value)? endCall,
    TResult? Function(ToggleMic value)? toggleMic,
    TResult? Function(ToggleSpeaker value)? toggleSpeaker,
    TResult? Function(ToggleVideo value)? toggleVideo,
    TResult? Function(ToggleView value)? toggleView,
    TResult? Function(SwitchCamera value)? switchCamera,
  }) {
    return toggleVideo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndCall value)? endCall,
    TResult Function(ToggleMic value)? toggleMic,
    TResult Function(ToggleSpeaker value)? toggleSpeaker,
    TResult Function(ToggleVideo value)? toggleVideo,
    TResult Function(ToggleView value)? toggleView,
    TResult Function(SwitchCamera value)? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleVideo != null) {
      return toggleVideo(this);
    }
    return orElse();
  }
}

abstract class ToggleVideo implements CallEvent {
  const factory ToggleVideo() = _$ToggleVideoImpl;
}

/// @nodoc
abstract class _$$ToggleViewImplCopyWith<$Res> {
  factory _$$ToggleViewImplCopyWith(
          _$ToggleViewImpl value, $Res Function(_$ToggleViewImpl) then) =
      __$$ToggleViewImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ToggleViewImplCopyWithImpl<$Res>
    extends _$CallEventCopyWithImpl<$Res, _$ToggleViewImpl>
    implements _$$ToggleViewImplCopyWith<$Res> {
  __$$ToggleViewImplCopyWithImpl(
      _$ToggleViewImpl _value, $Res Function(_$ToggleViewImpl) _then)
      : super(_value, _then);

  /// Create a copy of CallEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ToggleViewImpl implements ToggleView {
  const _$ToggleViewImpl();

  @override
  String toString() {
    return 'CallEvent.toggleView()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ToggleViewImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() endCall,
    required TResult Function() toggleMic,
    required TResult Function() toggleSpeaker,
    required TResult Function() toggleVideo,
    required TResult Function() toggleView,
    required TResult Function() switchCamera,
  }) {
    return toggleView();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? endCall,
    TResult? Function()? toggleMic,
    TResult? Function()? toggleSpeaker,
    TResult? Function()? toggleVideo,
    TResult? Function()? toggleView,
    TResult? Function()? switchCamera,
  }) {
    return toggleView?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? endCall,
    TResult Function()? toggleMic,
    TResult Function()? toggleSpeaker,
    TResult Function()? toggleVideo,
    TResult Function()? toggleView,
    TResult Function()? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleView != null) {
      return toggleView();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndCall value) endCall,
    required TResult Function(ToggleMic value) toggleMic,
    required TResult Function(ToggleSpeaker value) toggleSpeaker,
    required TResult Function(ToggleVideo value) toggleVideo,
    required TResult Function(ToggleView value) toggleView,
    required TResult Function(SwitchCamera value) switchCamera,
  }) {
    return toggleView(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndCall value)? endCall,
    TResult? Function(ToggleMic value)? toggleMic,
    TResult? Function(ToggleSpeaker value)? toggleSpeaker,
    TResult? Function(ToggleVideo value)? toggleVideo,
    TResult? Function(ToggleView value)? toggleView,
    TResult? Function(SwitchCamera value)? switchCamera,
  }) {
    return toggleView?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndCall value)? endCall,
    TResult Function(ToggleMic value)? toggleMic,
    TResult Function(ToggleSpeaker value)? toggleSpeaker,
    TResult Function(ToggleVideo value)? toggleVideo,
    TResult Function(ToggleView value)? toggleView,
    TResult Function(SwitchCamera value)? switchCamera,
    required TResult orElse(),
  }) {
    if (toggleView != null) {
      return toggleView(this);
    }
    return orElse();
  }
}

abstract class ToggleView implements CallEvent {
  const factory ToggleView() = _$ToggleViewImpl;
}

/// @nodoc
abstract class _$$SwitchCameraImplCopyWith<$Res> {
  factory _$$SwitchCameraImplCopyWith(
          _$SwitchCameraImpl value, $Res Function(_$SwitchCameraImpl) then) =
      __$$SwitchCameraImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwitchCameraImplCopyWithImpl<$Res>
    extends _$CallEventCopyWithImpl<$Res, _$SwitchCameraImpl>
    implements _$$SwitchCameraImplCopyWith<$Res> {
  __$$SwitchCameraImplCopyWithImpl(
      _$SwitchCameraImpl _value, $Res Function(_$SwitchCameraImpl) _then)
      : super(_value, _then);

  /// Create a copy of CallEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SwitchCameraImpl implements SwitchCamera {
  const _$SwitchCameraImpl();

  @override
  String toString() {
    return 'CallEvent.switchCamera()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SwitchCameraImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() endCall,
    required TResult Function() toggleMic,
    required TResult Function() toggleSpeaker,
    required TResult Function() toggleVideo,
    required TResult Function() toggleView,
    required TResult Function() switchCamera,
  }) {
    return switchCamera();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? endCall,
    TResult? Function()? toggleMic,
    TResult? Function()? toggleSpeaker,
    TResult? Function()? toggleVideo,
    TResult? Function()? toggleView,
    TResult? Function()? switchCamera,
  }) {
    return switchCamera?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? endCall,
    TResult Function()? toggleMic,
    TResult Function()? toggleSpeaker,
    TResult Function()? toggleVideo,
    TResult Function()? toggleView,
    TResult Function()? switchCamera,
    required TResult orElse(),
  }) {
    if (switchCamera != null) {
      return switchCamera();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EndCall value) endCall,
    required TResult Function(ToggleMic value) toggleMic,
    required TResult Function(ToggleSpeaker value) toggleSpeaker,
    required TResult Function(ToggleVideo value) toggleVideo,
    required TResult Function(ToggleView value) toggleView,
    required TResult Function(SwitchCamera value) switchCamera,
  }) {
    return switchCamera(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EndCall value)? endCall,
    TResult? Function(ToggleMic value)? toggleMic,
    TResult? Function(ToggleSpeaker value)? toggleSpeaker,
    TResult? Function(ToggleVideo value)? toggleVideo,
    TResult? Function(ToggleView value)? toggleView,
    TResult? Function(SwitchCamera value)? switchCamera,
  }) {
    return switchCamera?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EndCall value)? endCall,
    TResult Function(ToggleMic value)? toggleMic,
    TResult Function(ToggleSpeaker value)? toggleSpeaker,
    TResult Function(ToggleVideo value)? toggleVideo,
    TResult Function(ToggleView value)? toggleView,
    TResult Function(SwitchCamera value)? switchCamera,
    required TResult orElse(),
  }) {
    if (switchCamera != null) {
      return switchCamera(this);
    }
    return orElse();
  }
}

abstract class SwitchCamera implements CallEvent {
  const factory SwitchCamera() = _$SwitchCameraImpl;
}

/// @nodoc
mixin _$CallState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() reconnecting,
    required TResult Function() failed,
    required TResult Function() connected,
    required TResult Function(bool value, CallEvent event) changed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? reconnecting,
    TResult? Function()? failed,
    TResult? Function()? connected,
    TResult? Function(bool value, CallEvent event)? changed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? reconnecting,
    TResult Function()? failed,
    TResult Function()? connected,
    TResult Function(bool value, CallEvent event)? changed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Recconecting value) reconnecting,
    required TResult Function(Failed value) failed,
    required TResult Function(Connected value) connected,
    required TResult Function(Changed value) changed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Recconecting value)? reconnecting,
    TResult? Function(Failed value)? failed,
    TResult? Function(Connected value)? connected,
    TResult? Function(Changed value)? changed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Recconecting value)? reconnecting,
    TResult Function(Failed value)? failed,
    TResult Function(Connected value)? connected,
    TResult Function(Changed value)? changed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CallStateCopyWith<$Res> {
  factory $CallStateCopyWith(CallState value, $Res Function(CallState) then) =
      _$CallStateCopyWithImpl<$Res, CallState>;
}

/// @nodoc
class _$CallStateCopyWithImpl<$Res, $Val extends CallState>
    implements $CallStateCopyWith<$Res> {
  _$CallStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CallState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$CallStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of CallState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl implements Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'CallState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() reconnecting,
    required TResult Function() failed,
    required TResult Function() connected,
    required TResult Function(bool value, CallEvent event) changed,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? reconnecting,
    TResult? Function()? failed,
    TResult? Function()? connected,
    TResult? Function(bool value, CallEvent event)? changed,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? reconnecting,
    TResult Function()? failed,
    TResult Function()? connected,
    TResult Function(bool value, CallEvent event)? changed,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Recconecting value) reconnecting,
    required TResult Function(Failed value) failed,
    required TResult Function(Connected value) connected,
    required TResult Function(Changed value) changed,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Recconecting value)? reconnecting,
    TResult? Function(Failed value)? failed,
    TResult? Function(Connected value)? connected,
    TResult? Function(Changed value)? changed,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Recconecting value)? reconnecting,
    TResult Function(Failed value)? failed,
    TResult Function(Connected value)? connected,
    TResult Function(Changed value)? changed,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class Initial implements CallState {
  const factory Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$RecconectingImplCopyWith<$Res> {
  factory _$$RecconectingImplCopyWith(
          _$RecconectingImpl value, $Res Function(_$RecconectingImpl) then) =
      __$$RecconectingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RecconectingImplCopyWithImpl<$Res>
    extends _$CallStateCopyWithImpl<$Res, _$RecconectingImpl>
    implements _$$RecconectingImplCopyWith<$Res> {
  __$$RecconectingImplCopyWithImpl(
      _$RecconectingImpl _value, $Res Function(_$RecconectingImpl) _then)
      : super(_value, _then);

  /// Create a copy of CallState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$RecconectingImpl implements Recconecting {
  const _$RecconectingImpl();

  @override
  String toString() {
    return 'CallState.reconnecting()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RecconectingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() reconnecting,
    required TResult Function() failed,
    required TResult Function() connected,
    required TResult Function(bool value, CallEvent event) changed,
  }) {
    return reconnecting();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? reconnecting,
    TResult? Function()? failed,
    TResult? Function()? connected,
    TResult? Function(bool value, CallEvent event)? changed,
  }) {
    return reconnecting?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? reconnecting,
    TResult Function()? failed,
    TResult Function()? connected,
    TResult Function(bool value, CallEvent event)? changed,
    required TResult orElse(),
  }) {
    if (reconnecting != null) {
      return reconnecting();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Recconecting value) reconnecting,
    required TResult Function(Failed value) failed,
    required TResult Function(Connected value) connected,
    required TResult Function(Changed value) changed,
  }) {
    return reconnecting(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Recconecting value)? reconnecting,
    TResult? Function(Failed value)? failed,
    TResult? Function(Connected value)? connected,
    TResult? Function(Changed value)? changed,
  }) {
    return reconnecting?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Recconecting value)? reconnecting,
    TResult Function(Failed value)? failed,
    TResult Function(Connected value)? connected,
    TResult Function(Changed value)? changed,
    required TResult orElse(),
  }) {
    if (reconnecting != null) {
      return reconnecting(this);
    }
    return orElse();
  }
}

abstract class Recconecting implements CallState {
  const factory Recconecting() = _$RecconectingImpl;
}

/// @nodoc
abstract class _$$FailedImplCopyWith<$Res> {
  factory _$$FailedImplCopyWith(
          _$FailedImpl value, $Res Function(_$FailedImpl) then) =
      __$$FailedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FailedImplCopyWithImpl<$Res>
    extends _$CallStateCopyWithImpl<$Res, _$FailedImpl>
    implements _$$FailedImplCopyWith<$Res> {
  __$$FailedImplCopyWithImpl(
      _$FailedImpl _value, $Res Function(_$FailedImpl) _then)
      : super(_value, _then);

  /// Create a copy of CallState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FailedImpl implements Failed {
  const _$FailedImpl();

  @override
  String toString() {
    return 'CallState.failed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FailedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() reconnecting,
    required TResult Function() failed,
    required TResult Function() connected,
    required TResult Function(bool value, CallEvent event) changed,
  }) {
    return failed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? reconnecting,
    TResult? Function()? failed,
    TResult? Function()? connected,
    TResult? Function(bool value, CallEvent event)? changed,
  }) {
    return failed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? reconnecting,
    TResult Function()? failed,
    TResult Function()? connected,
    TResult Function(bool value, CallEvent event)? changed,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Recconecting value) reconnecting,
    required TResult Function(Failed value) failed,
    required TResult Function(Connected value) connected,
    required TResult Function(Changed value) changed,
  }) {
    return failed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Recconecting value)? reconnecting,
    TResult? Function(Failed value)? failed,
    TResult? Function(Connected value)? connected,
    TResult? Function(Changed value)? changed,
  }) {
    return failed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Recconecting value)? reconnecting,
    TResult Function(Failed value)? failed,
    TResult Function(Connected value)? connected,
    TResult Function(Changed value)? changed,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(this);
    }
    return orElse();
  }
}

abstract class Failed implements CallState {
  const factory Failed() = _$FailedImpl;
}

/// @nodoc
abstract class _$$ConnectedImplCopyWith<$Res> {
  factory _$$ConnectedImplCopyWith(
          _$ConnectedImpl value, $Res Function(_$ConnectedImpl) then) =
      __$$ConnectedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConnectedImplCopyWithImpl<$Res>
    extends _$CallStateCopyWithImpl<$Res, _$ConnectedImpl>
    implements _$$ConnectedImplCopyWith<$Res> {
  __$$ConnectedImplCopyWithImpl(
      _$ConnectedImpl _value, $Res Function(_$ConnectedImpl) _then)
      : super(_value, _then);

  /// Create a copy of CallState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ConnectedImpl implements Connected {
  const _$ConnectedImpl();

  @override
  String toString() {
    return 'CallState.connected()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ConnectedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() reconnecting,
    required TResult Function() failed,
    required TResult Function() connected,
    required TResult Function(bool value, CallEvent event) changed,
  }) {
    return connected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? reconnecting,
    TResult? Function()? failed,
    TResult? Function()? connected,
    TResult? Function(bool value, CallEvent event)? changed,
  }) {
    return connected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? reconnecting,
    TResult Function()? failed,
    TResult Function()? connected,
    TResult Function(bool value, CallEvent event)? changed,
    required TResult orElse(),
  }) {
    if (connected != null) {
      return connected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Recconecting value) reconnecting,
    required TResult Function(Failed value) failed,
    required TResult Function(Connected value) connected,
    required TResult Function(Changed value) changed,
  }) {
    return connected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Recconecting value)? reconnecting,
    TResult? Function(Failed value)? failed,
    TResult? Function(Connected value)? connected,
    TResult? Function(Changed value)? changed,
  }) {
    return connected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Recconecting value)? reconnecting,
    TResult Function(Failed value)? failed,
    TResult Function(Connected value)? connected,
    TResult Function(Changed value)? changed,
    required TResult orElse(),
  }) {
    if (connected != null) {
      return connected(this);
    }
    return orElse();
  }
}

abstract class Connected implements CallState {
  const factory Connected() = _$ConnectedImpl;
}

/// @nodoc
abstract class _$$ChangedImplCopyWith<$Res> {
  factory _$$ChangedImplCopyWith(
          _$ChangedImpl value, $Res Function(_$ChangedImpl) then) =
      __$$ChangedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool value, CallEvent event});

  $CallEventCopyWith<$Res> get event;
}

/// @nodoc
class __$$ChangedImplCopyWithImpl<$Res>
    extends _$CallStateCopyWithImpl<$Res, _$ChangedImpl>
    implements _$$ChangedImplCopyWith<$Res> {
  __$$ChangedImplCopyWithImpl(
      _$ChangedImpl _value, $Res Function(_$ChangedImpl) _then)
      : super(_value, _then);

  /// Create a copy of CallState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
    Object? event = null,
  }) {
    return _then(_$ChangedImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as bool,
      null == event
          ? _value.event
          : event // ignore: cast_nullable_to_non_nullable
              as CallEvent,
    ));
  }

  /// Create a copy of CallState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CallEventCopyWith<$Res> get event {
    return $CallEventCopyWith<$Res>(_value.event, (value) {
      return _then(_value.copyWith(event: value));
    });
  }
}

/// @nodoc

class _$ChangedImpl implements Changed {
  const _$ChangedImpl(this.value, this.event);

  @override
  final bool value;
  @override
  final CallEvent event;

  @override
  String toString() {
    return 'CallState.changed(value: $value, event: $event)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChangedImpl &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.event, event) || other.event == event));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value, event);

  /// Create a copy of CallState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ChangedImplCopyWith<_$ChangedImpl> get copyWith =>
      __$$ChangedImplCopyWithImpl<_$ChangedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() reconnecting,
    required TResult Function() failed,
    required TResult Function() connected,
    required TResult Function(bool value, CallEvent event) changed,
  }) {
    return changed(value, event);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? reconnecting,
    TResult? Function()? failed,
    TResult? Function()? connected,
    TResult? Function(bool value, CallEvent event)? changed,
  }) {
    return changed?.call(value, event);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? reconnecting,
    TResult Function()? failed,
    TResult Function()? connected,
    TResult Function(bool value, CallEvent event)? changed,
    required TResult orElse(),
  }) {
    if (changed != null) {
      return changed(value, event);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Recconecting value) reconnecting,
    required TResult Function(Failed value) failed,
    required TResult Function(Connected value) connected,
    required TResult Function(Changed value) changed,
  }) {
    return changed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Recconecting value)? reconnecting,
    TResult? Function(Failed value)? failed,
    TResult? Function(Connected value)? connected,
    TResult? Function(Changed value)? changed,
  }) {
    return changed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Recconecting value)? reconnecting,
    TResult Function(Failed value)? failed,
    TResult Function(Connected value)? connected,
    TResult Function(Changed value)? changed,
    required TResult orElse(),
  }) {
    if (changed != null) {
      return changed(this);
    }
    return orElse();
  }
}

abstract class Changed implements CallState {
  const factory Changed(final bool value, final CallEvent event) =
      _$ChangedImpl;

  bool get value;
  CallEvent get event;

  /// Create a copy of CallState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ChangedImplCopyWith<_$ChangedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
